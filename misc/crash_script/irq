Hardware interrupts were introduced as a way to avoid wasting the processor's 
valuable time in polling loops, waiting for external events.  They may be 
implemented in hardware as a distinct system with control lines, or they may be
integrated into the memory subsystem.

If implemented in hardware, an interrupt controller circuit such as Programmable
Interrupt Controller (PIC) may be connected between the interrupting device and
the processor's interrupt pin to multiplex several sources of interrupt onto the
one or two CPU lines typically available.  If implemented as part of the memory
controller, interrupts are mapped into the system's memory address space.

Interrupts can be categorized into:

Maskable interrupt (IRQ) is a hardware interrupt that may be ignored by setting
a bit in an interrupt mask register's (IMR) bit-mask.

Non-maskable interrupt (NMI) is a hardware interrupt that lack an associated 
bit-mask, so that it can never be ignored.  NMIs are often used for timers, 
especially watchdog timers.

Inter-processor interrupt (IPI) is a special case of interrupt that is generated
by one processor to interrupt another processor in a multiprocessor system.

Software interrupt is an interrupt generated within a processor by executing an
instruction.  Software interrupts are often used to implement system calls because
they implement a subroutine call with a CPU ring level change.

Spurious interrupt is a hardware interrupt that is unwanted.  They are typically
generated by system conditions such as electrical interference on an interrupt
line or through incorrectly designed hardware.

Processors typically have an internal interrupt mask wich allows software to
ignore all external hardware interrupts while it is set.  This mask may offer
faster access than accessing an interruput mask register (IMR) in a PIC, or
disabling interrupts in the device itself.  In some cases, such as the X86
architecture, disabling and enabling interrupts on the processor itself act as
a memory barrier, however it may actually be slower.

An interrupt that leaves the machine in a well-defined state is called a precise
interrupt.  Such an interrupt has four properties:

	The program Counter (PC) is saved in a known place.

	All instructions before the one pointed to by the PC have fully executed.

	No instruction beyond the one pointed to by the PC has been executed (that
	is no prohibition on instruction beyond that in PC, it is just that any 
	changes they make to registers or memory must be undone before the interrupt
	happens).

	The execution state of the instruction pointed to by the PC is known.

Types of Interrupts
Level-triggered
A level-triggered interrupt is a class of interrupts where the presence of an
unserviced interrupt is indicated by a high level (1), or low level (0), of the
interrupt request line.  A device wishing to signal an interrupt drives line to
its active level, and then holds it at that level until serviced.  It ceases 
asserting the line when the CPU commands it to or otherwise handles the condition
that caused it to signal the interrupt.

Typically, the processor samples the interrupt input at predefined times during 
each bus cycle such as state T2 for the Z80 microprocessor.  If the interrupt 
isn't active when the processor samples it, the CPU doesn't see it.  One possible
use for this type of interrupt is to minimize spurious signals from a noisy
interrupt line: a spurious pulse will often be so short that it is not noticed.

Multiple devices may share a level-triggered interrupt line if they are designed
to.  The interrupt line must have a pull-down or pull-up resistor so that when
not actively driven it settles to its inactive state.  Devices actively assert
the line to indicate an outstanding interrupt, but let the line float (do not
actively drive it) when not signalling an outstanding interrupt.

This class of interrupts is favored by some because of a convenient behavior 
when the line is shared.  upon detecting assertion of the interrupt line, the
CPU must search through the devices sharing it until one requiring service is
detected.  After servicing this device, the CPU may recheck the interrupt line
status to determine whether any other device also need service.  If the line is
now de-asserted, the CPU avoids checking the remaining devices on the line.
Since some devices interrupt more frequently than others, and other device 
interrupts are particularly expensive, a careful ordering of device check is
employed to increase efficiency.

There are also serious problem with sharing level-triggered interrupts. As long
as any device on the line has an outstanding request for service the line remains
asserted, so it is not possible to detect a change in the status of any other
device.  Deferring servicing a low-priority device is not an option, because
this would prevent detection of service requests from higher-priority devices.
If there is a device on the line that the CPU doesnt know how to service, then 
any interrupt from that device permanently blocks all interrupts from the other
devices.

The original PCI standard mandated shareable level-triggered interrupts.  New 
version of PCI allow, and PCI Express requires the use of message-signalled 
interrupts.

Edge-triggered
An edge-triggered interrupt is a class of interrupts that are signalled by a
level transition on the interrupt line, either a falling edge (1 to 0) or a 
rising edge (0 to 1).  A device wishing to signal an interrupt drives a pluse
noto the line and then releases the line to its quiescent state.  If the pulse 
is too short to be detected by polled I/O then special hardware may be required
to detect the edge.

Multiple devices may share an edge-triggered interrupt line if they are designed
to.  The interrupt line must have a pull-down or pull-up resistor so that when
not actively driven it settles to one particular state.  Devices signal an
interrupt by briefly driving the line to its non-default state, and let the line
float (do not actively drive it) when not signnalling an interrupt.  This type
of connection is also referred to as open collector.  The line then carries all
the pulses generated by all the devices.  (this is analogous to the pull cord on
some buses and trolleys that any passenger can pull to signal the driver that 
they are requesting a stop.)  However, interrupt pulses from different devices
may merge if they occur close in time.  To avoid losing interrupts the CPU must 
trigger on the trailing edig of the pulse (e.g. the rising edge if the line is
pulled up and driven low).  After detecting an interrupt the CPU must check all
the device for service requirements.

Edge-triggered interrupts do not suffer the problems that level-triggered 
interrupts have with sharing.  Service of a low-priority device can be postponed
arbitrarily, and interrupts will continue to be received from the high-priority
devices that are being serviced.  If there is a device that the CPU does not know
how to service, it may cause a spurious interrupt, or even periodic spurious 
interrupts, but it doesn't interfere with the interrupt signalling of the other
devices.  hwever, it is fairly easy for an edge triggered interrupt to be missed
- for example if interrupts have to be masked for a period - and unless there is
some type of hardware latch that records the event it is impossible to recover. 
Such problems caused many "lockups" in early computer hardware because the 
processor did not know it was expected to do something.  More modern hardware 
often has one or more interrupt status registers that latch the interrupt request;
well written edge-driven interrupt software often checks cush registers to ensure
events are not missed.

The elderly Industry Standard Architecture (ISA) bus uses edge-triggered
interrupts, but does not mandate that devices be able to share them.  the parallel
port also uses edge-triggered interrupts.  Many older devices assume that they
have exclusive use of their interrupt line, making it electrically unsafe to
share them.  However, ISA motherboards include pull-up resistors on the IRQ
lines, so well-behaved devices share ISA interrupts just fine.

Hybrid
Some systems use a hybrid of level-triggered and edge-triggered signalling. The
hardware not only looks for an edge, but it also verifies that the interrupt
signal stays active for a certain period of time.

A common use of a hybrid interrupts is for the NMI (non-maskable interrupt) 
input.  Because NMIs generally signal major - or even catastrophic - system 
events, a good implementation of this signal tries to ensure that the interrupt
is valid by verifying that it remains active for a period of time.  This 2-step
approach helps to eliminate false interrupts from affecting the system.

Message-signaled
A message-signalled interrupt does not use a physical interrupt line.  Instead,
a device signals its request for service by sending a short message over some 
communications medium, typically a computer bus.  The message might be of a type
reserved for interrupts, or it might be of some pre-existing type such as a 
memory write.

Message-signalled interrupts behave very much like edge-triggered interrupts, 
in that the interrupt is a mementary signal rather than a continuous condition.
Interrupt-handling software threts the two in much the same manner.  Typically,
multiple pending message-signalled interrupts with the same message (the same
virtual interrupt line) are allowed to merge, just as closely-spaced 
edge-triggered insterrupts can merge.

Message-signalled interrupt vectors can be shared, to the extend that the
underlying communication medium can be shared.  No additional effort is required.

Because the identity of the interrupt is indicated by a pattern of data bits, 
not requiring a separate physical conductor, many more distinct interrupts 
can be efficiently handled.  This reduces the need for sharing.  Interrupt
messages can also be passed over a serial bus, not requiring any additional lines.

PCI Express, a serial computer bus, uses message-signalled interrupts exclusively.

==============================================================================
Message Signaled Interrupts, in PCI 2.2 and later and PCI Express, are an 
alternative way of generating an interrupt.  Trraditionally, a device has an 
interrupt pin which it asserts when it wants to interrupt the host CPU.  While
PCI Express doesn't have seperate interrupt pins, it has special messages to
allow it to emulate a pin assertion or deassertion.  Message Signaled Interrupts
allow the device to write a small amount of data to a special address in memory
space.  The chipset will deliver the corresponding interrupt to a CPU.

A common misconception with Message Signaled Interupts is that they allow the
device to send data to the CPU as part of the interrupt.  The data that is sent
as part of the write is used by the chipset to determine which interrupt to 
trigger on which CPU; it is not available for the device to communicate 
additional information to the interrupt handler.

Advantages Over pin-based interrupts
While more complex to implement in a device, MSI has some significant advantages.

On the mechanical side, fewer pins makes for a simpler, cheaper, and more 
reliable connector.  While this is no advantage to the standard PCI connector,
PCI Express takes advantage of these savings.

MSI increases the number of interrupts that are possible.  While conventional 
PCI was limited to 4 interrupts per card (and, because they were shared among
all cards, most used just 1), message signaled interrupts allow dozens of 
interrupts per card, when that is useful.

There is also a slight performance advantage.  In software, a pin-based interrupt
could race with a posted write  to memory.  That is, the PCI device would write
data to memory and then send an interrupt to indicate the DMA write was complete.
However, a PCI bridge or memory controller might buffer the write in order to not
interfere with some other memory use.  The interrupt could arrive before the DMA 
write was complete, and the processor could read stale data from memory.  To
prevent this race, interrupt handlers were required to read from the device to 
ensure that the DMA write had finished.  This read had a moderate performance 
penalty.  An MSI write cannot pass a DMA write, so the race is eliminated.

MSI types
PCI defines two optional extensions to support Message Signaled Interrupts, MSI
and MSI-X.  While PCIe is software compatible with legacy interrupts it requires
MSI or MSI-X.

MSI
MSI (first defined in PCI 2.2) permits a device to allocate 1,2,4,8,16 or 32
interrupts.  the device is programmed with an address to write to (generally a
control register in an interrupt controller), and a 16-bit data word to identify
it.  The interrupt number is added to the data word to identify the interrupt.
Some platforms such as Windows do not use all 32 interrupts but only use up to
16 interrupts.

MSI-X
MSI-X (first defined in PCI 3.0) permits a device to allocate up to 2048
interrupts.  The single address used by original MSI was found to be
restrictive for some architectures.  In particular, it made it difficult to
target individual interrupts to different processors, which is helpful in some
high-speed networking applicatoins.  MSI-X allow a larger number of interrupts
and gives each one a separate target address and data word.  Devices with MSI-X
do not necessarily support 2048 interrupts but at least 64 which is double than
the maximum MSI interrupts.

Optional features in MSI (64-bit addressing and interrupt masking) are also
mandatory with MSI-X.
==============================================================================

Typically, on systems using the Intel 8259, 16 IRQs are used.  IRQs 0 to 7 are 
managed by one Intel 8259 PIC, and IRQs 8 to 15 by a 2nd Intel 8259 PIC.  The
first PIC, the master, is the only one that directly signals the CPU.  The 2nd
PIC, the slave, instead signals to the master on its IRQ 2 line, and the master
passes the signal on to the CPU.

On newer systems using the Intel APIC Architecture, typically there are 24 IRQs
available, and the extra 8 IRQs are used to route PCI interrupts, avoiding 
conflict between dynamically configured PCI interrupts and statically configured
ISA interrupts.  On early APIC systems with only 16 IRQs or with only Intel 8259
interrupt controllers, PCI interrupt lines were routed to the 16 IRQs using a 
PIR integrated into the southbridge.

Master PIC
IRQ 0 - system timer (cannot be changed)
IRQ 1 - keyboard controller (cannot be changed)
IRQ 2 - cascaded signals from IRQs 8 - 15
IRQ 3 - serial port control for COM2 (shared w/ COM4 if present)
IRQ 4 - serial port controller for COM1 (shared w/ COM1 if present)
IRQ 5 - LPT port 2 or sound card
IRQ 6 - floppy disk controller
IRQ 7 - LPT port 1 or sound card (8-bit Sound Blaster and compatibles)

Slave PIC
IRQ 8 - RTC Timer
IRQ 9 - open interrupt / available or SCSI host adapter
IRQ 10 - open interrupt / available or SCSI or NIC
IRQ 11 - open interrupt / available or SCSI or NIC
IRQ 12 - mouse on PS/2 connector
IRQ 13 - math co-processor or integrated floating point uint or inter-processor
         interrupt (use depends on OS)
IRQ 14 - primary ATA channel
IRQ 15 - secondary ATA channel

#define NR_IRQS (NR_VECTORS + (32 *NR_CPUS))
#define NR_VECTORS 256
#ifdef X86
#define NR_CPUS  (256)
#endif
#ifdef X86_64
#define NR_CPUS  (256)
#endif


/proc/interrupts
/proc/irq/<#>
/proc/stat

